var _0xodo='jsjiami.com.v6',_0x213f=[_0xodo,'w4XCnxNGWi1Dw6fDj1seworCmA==','CsKVacOyC1bDlMOYWcKIOsKQ','wp8Nw4ZZaCwtw78sw4bCjA==','ecKEwo3CvAcJw4rCucOPJEY7wrvDnsOmP17CpcK1wqI=','wrFMSsOBGQ==','w5lEJcK5J8KkMXI6wowtwpfDoMOp','wqbChsKReDUV','wooPw4tHcw==','Sx50wpx4w4XCs13CtcOjwqjCsBvCrw==','RU/DlwHCvMOEw6/CnA12Lg==','w4zCr8O4G8O0Pg==','ZcKdwpPCtg==','w5IoVsOtBnDCnmzCosK1SDw0LcKnw7rChw==','w4pBwoXCtMKUw4XDsktEckM=','wqMgw5HCn8OSw7UAwqc=','wrBUQx0IW8O1aS/DihA=','ScOUW8KeCjzDucKnw443ecOfOFYUczjDiSrDmQ==','wr9lw6Vxwpc1ShbClz3DjSbCmcOPwonDsA==','wrtCFXFqw5BcBwA=','CcKNwqDCoBNTZSJccg==','J8Oxwp04IQ==','NAQTw4JI','wostwrZGwpZJaMKQJsKqSxY=','w69xwq7CmsKP','wrxPw6UkbDEuwp7DjcKbdGE=','jsltjNXLiqtzDwamil.unPcom.v6=='];(function(_0x208a89,_0x4fbcd9,_0x487c52){var _0x1f54b3=function(_0x6ae337,_0x273d05,_0x2c32d9,_0x27d964,_0x42ac77){_0x273d05=_0x273d05>>0x8,_0x42ac77='po';var _0x4c1135='shift',_0x142d26='push';if(_0x273d05<_0x6ae337){while(--_0x6ae337){_0x27d964=_0x208a89[_0x4c1135]();if(_0x273d05===_0x6ae337){_0x273d05=_0x27d964;_0x2c32d9=_0x208a89[_0x42ac77+'p']();}else if(_0x273d05&&_0x2c32d9['replace'](/[ltNXLqtzDwlunP=]/g,'')===_0x273d05){_0x208a89[_0x142d26](_0x27d964);}}_0x208a89[_0x142d26](_0x208a89[_0x4c1135]());}return 0x7816b;};return _0x1f54b3(++_0x4fbcd9,_0x487c52)>>_0x4fbcd9^_0x487c52;}(_0x213f,0x96,0x9600));var _0x28e1=function(_0x132895,_0x18d85b){_0x132895=~~'0x'['concat'](_0x132895);var _0x43082e=_0x213f[_0x132895];if(_0x28e1['RcJEwB']===undefined){(function(){var _0x59785c=typeof window!=='undefined'?window:typeof process==='object'&&typeof require==='function'&&typeof global==='object'?global:this;var _0x3ad2e4='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0x59785c['atob']||(_0x59785c['atob']=function(_0x1a436a){var _0x45f5a2=String(_0x1a436a)['replace'](/=+$/,'');for(var _0x16b556=0x0,_0x2f740e,_0x3aa0d3,_0x53d0f4=0x0,_0x1f9a1e='';_0x3aa0d3=_0x45f5a2['charAt'](_0x53d0f4++);~_0x3aa0d3&&(_0x2f740e=_0x16b556%0x4?_0x2f740e*0x40+_0x3aa0d3:_0x3aa0d3,_0x16b556++%0x4)?_0x1f9a1e+=String['fromCharCode'](0xff&_0x2f740e>>(-0x2*_0x16b556&0x6)):0x0){_0x3aa0d3=_0x3ad2e4['indexOf'](_0x3aa0d3);}return _0x1f9a1e;});}());var _0x4c405d=function(_0x4ef22d,_0x18d85b){var _0x3d7963=[],_0x22ac68=0x0,_0x8e6409,_0x14eeb6='',_0x1a1714='';_0x4ef22d=atob(_0x4ef22d);for(var _0x5dd6e7=0x0,_0x19a7a9=_0x4ef22d['length'];_0x5dd6e7<_0x19a7a9;_0x5dd6e7++){_0x1a1714+='%'+('00'+_0x4ef22d['charCodeAt'](_0x5dd6e7)['toString'](0x10))['slice'](-0x2);}_0x4ef22d=decodeURIComponent(_0x1a1714);for(var _0x2413be=0x0;_0x2413be<0x100;_0x2413be++){_0x3d7963[_0x2413be]=_0x2413be;}for(_0x2413be=0x0;_0x2413be<0x100;_0x2413be++){_0x22ac68=(_0x22ac68+_0x3d7963[_0x2413be]+_0x18d85b['charCodeAt'](_0x2413be%_0x18d85b['length']))%0x100;_0x8e6409=_0x3d7963[_0x2413be];_0x3d7963[_0x2413be]=_0x3d7963[_0x22ac68];_0x3d7963[_0x22ac68]=_0x8e6409;}_0x2413be=0x0;_0x22ac68=0x0;for(var _0x387f00=0x0;_0x387f00<_0x4ef22d['length'];_0x387f00++){_0x2413be=(_0x2413be+0x1)%0x100;_0x22ac68=(_0x22ac68+_0x3d7963[_0x2413be])%0x100;_0x8e6409=_0x3d7963[_0x2413be];_0x3d7963[_0x2413be]=_0x3d7963[_0x22ac68];_0x3d7963[_0x22ac68]=_0x8e6409;_0x14eeb6+=String['fromCharCode'](_0x4ef22d['charCodeAt'](_0x387f00)^_0x3d7963[(_0x3d7963[_0x2413be]+_0x3d7963[_0x22ac68])%0x100]);}return _0x14eeb6;};_0x28e1['XDxBXU']=_0x4c405d;_0x28e1['APAiVW']={};_0x28e1['RcJEwB']=!![];}var _0x3b8b6c=_0x28e1['APAiVW'][_0x132895];if(_0x3b8b6c===undefined){if(_0x28e1['DFXYSV']===undefined){_0x28e1['DFXYSV']=!![];}_0x43082e=_0x28e1['XDxBXU'](_0x43082e,_0x18d85b);_0x28e1['APAiVW'][_0x132895]=_0x43082e;}else{_0x43082e=_0x3b8b6c;}return _0x43082e;};var real_types=['Fake',_0x28e1('0','&PGZ'),'Middle',_0x28e1('1','!@qZ'),_0x28e1('2','Ljza'),_0x28e1('3','#96)'),_0x28e1('4','EaLb'),_0x28e1('5','%g@%')];var lby_types=['Opposite',_0x28e1('6','vRva'),'Switch\x20Opposite',_0x28e1('7','Ljza'),_0x28e1('8','Qw@G')];var real_additional_types=['None','Full\x20Sine','Full\x20Jitter','Half\x20Sine',_0x28e1('9','#b7s')];var moving_real_types=['None',_0x28e1('a','a]Ww'),'Jitter',_0x28e1('b','#96)')];var override=UI['AddCheckbox'](_0x28e1('c','K)jD'));var ui={'real_type':UI[_0x28e1('d','LiT^')]('Real\x20type',real_types),'lby_type':UI['AddDropdown'](_0x28e1('e','(1P$'),lby_types),'real_additional_type':UI[_0x28e1('f','Cq33')](_0x28e1('10','@CyU'),real_additional_types),'moving_real_type':UI['AddDropdown'](_0x28e1('11','&8FC'),moving_real_types),'smart_range':UI['AddSliderInt']('Smart\x20Range',0x0,0x64)};function LBY_opposite(_0xfa809e){var _0x593fa2={'fPeoi':_0x28e1('12','CURq'),'ZBRcj':'m_angEyeAngles[0]','VjvnW':function(_0x30f1d7,_0x2b60e4){return _0x30f1d7>_0x2b60e4;},'QiLfJ':function(_0x1c9605,_0x5a4979){return _0x1c9605>_0x5a4979;},'dTOji':function(_0x11cc54,_0x35ea4b){return _0x11cc54<_0x35ea4b;}};var _0x549750=Local['GetRealYaw']();var _0x54daae=Local[_0x28e1('13','8JjE')]();var _0xe51fd5=Entity['GetLocalPlayer']();var _0x152b23=Entity['GetProp'](_0xe51fd5,_0x593fa2['fPeoi'],_0x593fa2[_0x28e1('14','u64q')])[0x1];var _0x19bb33=_0x152b23-_0x54daae;if(_0x593fa2[_0x28e1('15','o$EZ')](_0x19bb33,0xb4))_0x19bb33-=0x168;if(_0x19bb33<-0xb4)_0x19bb33+=0x168;if(_0x593fa2['QiLfJ'](_0x19bb33,-0x14)&&_0xfa809e){AntiAim[_0x28e1('16','C(Ai')](0x5a);return 0x5a;}else if(_0x593fa2[_0x28e1('17','LiT^')](_0x19bb33,0x14)&&!_0xfa809e){AntiAim['SetLBYOffset'](-0x5a);return-0x5a;}else{AntiAim[_0x28e1('18','jKtZ')](0xb4);return 0xb4;}};_0xodo='jsjiami.com.v6';
function smart_middle(inverter)
{
    var local = Entity.GetLocalPlayer()
    var v = Entity.GetProp(local, "CBasePlayer", "m_vecVelocity[0]")
    var len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])
    AntiAim.SetRealOffset(len < 30 ? 0 : (inverter ? 58 : -58))
    return len < 30 ? 0 : (inverter ? 58 : -58)
}
function follow_fake(inverter, a)
{
    var real = Local.GetRealYaw()
    var fake = Local.GetFakeYaw()
    var local = Entity.GetLocalPlayer()
    var yaw = Entity.GetProp(local, "CCSPlayer", "m_angEyeAngles[0]")[1]
    var delta = yaw - fake
    if(delta > 180)
        delta -= 360
    if(delta < -180)
        delta += 360
    AntiAim.SetRealOffset(a ? delta : -delta)
    return a ? delta : -delta
}
function half_sine(inverter, real_yaw)
{
    var sine = ((Math.sin(Globals.Curtime() * 5) + 1) / 2) * 58
    var new_yaw = inverter ? real_yaw + sine : real_yaw - sine
    AntiAim.SetRealOffset(-new_yaw)
}
function half_jitter(inverter, real_yaw)
{
    var rand = Math.random() * 58
    var new_yaw = inverter ? real_yaw + rand : real_yaw - rand
    AntiAim.SetRealOffset(-new_yaw)
}
var flip = false
function switch_opposite(inverter)
{
    var fake = LBY_opposite(flip ? !inverter : inverter)
    if(fake == 180)
    {
        flip = !flip
    }
}
var flip2 = false
var last = 0
function switch_real_moving(inverter)
{
    var local = Entity.GetLocalPlayer()
    var v = Entity.GetProp(local, "CBasePlayer", "m_vecVelocity[0]")
    var len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])
    if(len < 30)
        return
    var sim = Globals.Curtime() - Entity.GetProp(local, "CBaseEntity", "m_flSimulationTime")
    if(last > sim)
    {
        flip2 = !flip2
    }
    AntiAim.SetRealOffset(flip2 ? 58 : -58)
    last = sim
}
function jitter_real_moving(inverter)
{
    var local = Entity.GetLocalPlayer()
    var v = Entity.GetProp(local, "CBasePlayer", "m_vecVelocity[0]")
    var len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])
    if(len < 30)
        return

    var new_yaw = Math.random() * 58 * 2 - 58
    AntiAim.SetRealOffset(new_yaw)
}
function sine_real_moving(inverter)
{
    var local = Entity.GetLocalPlayer()
    var v = Entity.GetProp(local, "CBasePlayer", "m_vecVelocity[0]")
    var len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])
    if(len < 30)
        return
    var factor = 0
    if(len < 90)
        factor = 40
    else
        factor = 30
    var sine = Math.sin(Globals.Curtime() * 5) * factor
    AntiAim.SetRealOffset(sine)
}
function RadToDeg(a){
    return a * 180 / Math.PI
}
function calc_angle(source, entityPos){
    var delta = []
    delta[0] = source[0] - entityPos[0]
    delta[1] = source[1] - entityPos[1]
    delta[2] = source[2] - entityPos[2]
    var angles = []
    var viewangles = Local.GetViewAngles()
    angles[0] = RadToDeg(Math.atan(delta[2] / Math.hypot(delta[0], delta[1])))
    angles[1] = RadToDeg(Math.atan(delta[1] / delta[0]))
    angles[2] = 0
    if(delta[0] >= 0)
        angles[1] += 180
    while(angles[1] > 180)
        angles[1] -= 360
    while(angles[1] < -180)
        angles[1] += 360
    return angles
}
function closest_to_fov()
{
    var local = Entity.GetLocalPlayer()
    var eye = Entity.GetEyePosition(local)
    var ang = Local.GetViewAngles()
    var enemies = Entity.GetEnemies()
    var closest = -1
    var last = 180
    for(i in enemies)
    {
        if(!Entity.IsAlive(enemies[i]))
            continue
        var ang_to = calc_angle(eye, Entity.GetHitboxPosition(enemies[i], 5))
        ang_to[0] -= ang[0]
        ang_to[1] -= ang[1]
        var len = Math.sqrt(ang_to[0]*ang_to[0]+ang_to[1]*ang_to[1])
        if(len < last)
        {
            last = len
            closest = enemies[i]
        }
    }
    return closest
}
function ang_vec(a){
    var sy = Math.sin(a[1])
    var cy = Math.cos(a[1])
    var sp = Math.sin(a[0])
    var cp = Math.cos(a[0])
    return [cp*cy,cp*sy,-sp]
}
function vmf(a,b){
    return [a[0]*b,a[1]*b,a[2]*b]
}
function va(a,b){
    return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]
}
var smart = false
function smart_yaw(side)
{
    var local = Entity.GetLocalPlayer()

    var ent = closest_to_fov()
    if(ent == -1)
        return
    var eye = Entity.GetEyePosition(local)
    var ang = calc_angle(eye, Entity.GetHitboxPosition(ent, 5))
    var left_ang = [0,(ang[1]+90)/180*Math.PI,0] // fucking stupid, had a bug with it and SOMEHOW this fixed it (1000 iq coder)
    var right_ang = [0,(ang[1]-90)/180*Math.PI,0] // fucking stupid, had a bug with it and SOMEHOW this fixed it (1000 iq coder)
    var normalize = function(vec)
    {
        if(vec[1] > 180)
            vec[1] -= 360
        if(vec[1] < -180)
            vec[1] += 360
        return vec
    }
    left_ang = normalize(left_ang)
    right_ang = normalize(right_ang)
    var range = UI.GetValue.apply(null, ui.smart_range)
    var left = vmf(ang_vec(left_ang), range)
    var right = vmf(ang_vec(right_ang), range)
    var temp_left = va(left, eye)
    var temp_right = va(right, eye)
    var tr_left = Trace.Line(local, eye, temp_left)
    var tr_right = Trace.Line(local, eye, temp_right)

    left = vmf(ang_vec(left_ang), range * tr_left[1])
    temp_left = va(left, eye)
    right = vmf(ang_vec(right_ang), range * tr_right[1])
    temp_right = va(right, eye)
    tr_left = Trace.Line(local, temp_left, Entity.GetHitboxPosition(ent, 5))
    tr_right = Trace.Line(local, temp_right, Entity.GetHitboxPosition(ent, 5))
    if(tr_left[0] && !tr_right[0])
        return true
    if(!tr_left[0] && tr_right[0])
        return false
    if(!tr_left[0] && !tr_right[0])
        return side
}
function autodirection()
{
    var local = Entity.GetLocalPlayer()

    var ent = closest_to_fov()
    if(ent == -1)
        return
    var eye = Entity.GetEyePosition(local)
    var ang = calc_angle(eye, Entity.GetHitboxPosition(ent, 5))
    var left_ang = [0,(ang[1]+90)/180*Math.PI,0] // fucking stupid, had a bug with it and SOMEHOW this fixed it (1000 iq coder)
    var right_ang = [0,(ang[1]-90)/180*Math.PI,0] // fucking stupid, had a bug with it and SOMEHOW this fixed it (1000 iq coder)
    var normalize = function(vec)
    {
        if(vec[1] > 180)
            vec[1] -= 360
        if(vec[1] < -180)
            vec[1] += 360
        return vec
    }
    left_ang = normalize(left_ang)
    right_ang = normalize(right_ang)
    var range = 50
    var left = vmf(ang_vec(left_ang), range)
    var right = vmf(ang_vec(right_ang), range)
    var temp_left = va(left, eye)
    var temp_right = va(right, eye)
    var tr_left = Trace.Line(local, eye, temp_left)
    var tr_right = Trace.Line(local, eye, temp_right)

    left = vmf(ang_vec(left_ang), range * tr_left[1])
    temp_left = va(left, eye)
    right = vmf(ang_vec(right_ang), range * tr_right[1])
    temp_right = va(right, eye)
    tr_left = Trace.Line(local, temp_left, Entity.GetHitboxPosition(ent, 5))
    tr_right = Trace.Line(local, temp_right, Entity.GetHitboxPosition(ent, 5))
    if(tr_left[0] && !tr_right[0])
        return 90
    if(!tr_left[0] && tr_right[0])
        return -90
    if(!tr_left[0] && !tr_right[0])
        return 0
}
function smart_lby(inverter, flipped)
{
    LBY_opposite(flipped ? smart_yaw(inverter) : !smart_yaw(inverter))
}
var enemy_brute_stage = []
function reset()
{
    enemy_brute_stage = []
}
var shots_fired = []
var last_shots_fired = []
var bullet_pos = []
var hurt = -1
var shooting = -1
function weapon_fire()
{
    if(Entity.GetEntityFromUserID(Event.GetInt("userid")) == Entity.GetLocalPlayer())
        return
    if(!shots_fired[Entity.GetEntityFromUserID(Event.GetInt("userid"))])
        shots_fired[Entity.GetEntityFromUserID(Event.GetInt("userid"))] = 0
    shots_fired[Entity.GetEntityFromUserID(Event.GetInt("userid"))]++
    shooting = Entity.GetEntityFromUserID(Event.GetInt("userid"))
}
function player_hurt()
{
    if(Entity.GetEntityFromUserID(Event.GetInt("attacker")) == Entity.GetLocalPlayer())
        return
    hurt = Entity.GetEntityFromUserID(Event.GetInt("attacker"))
}
function bullet_impact()
{
    if(Entity.GetEntityFromUserID(Event.GetInt("userid")) == Entity.GetLocalPlayer())
        return
    if(Entity.GetEntityFromUserID(Event.GetInt("userid")) == shooting)
        bullet_pos = [Event.GetFloat("x"), Event.GetFloat("y"), Event.GetFloat("z")]
}
function process_shot()
{
    if(shooting == -1)
        return
    var eye = Entity.GetEyePosition(shooting)
    var impact = bullet_pos
    var local = Entity.GetLocalPlayer()
    var head = Entity.GetHitboxPosition(local, 0)
    var ang_to_impact = calc_angle(eye, impact)
    var ang_to_local = calc_angle(eye, head)
    var delta = [ang_to_local[0]-ang_to_impact[0],ang_to_local[1]-ang_to_impact[1], 0]
    var len = Math.sqrt(delta[0]*delta[0]+delta[1]*delta[1])
    delta = [head[0]-eye[0],head[1]-eye[1],head[2]-eye[2]]
    var dist = Math.sqrt(delta[0]*delta[0]+delta[1]*delta[1]+delta[2]*delta[2])
    if(dist > 500)
        dist = 500
    dist = 500 - dist
    dist /= 450
    dist *= 20
    if(dist < 2)
        dist = 2
    if(hurt != shooting && len < dist)
    {
 
        if(!enemy_brute_stage[shooting])
            enemy_brute_stage[shooting] = 0
        enemy_brute_stage[shooting] = (enemy_brute_stage[shooting] + 1) % 3
    }
    shooting = -1
    hurt = -1
    bullet_pos = []
}
var brutee = UI.AddCheckbox("Anti-Brute")
UI.AddLabel("- Overrides Anti-Aim settings")
var autodir = UI.AddCheckbox("Autodirection")
function onCreateMove()
{
    if(UI.GetValue.apply(null, autodir))
    {
        UI.SetValue("Anti-Aim", "Rage Anti-Aim", "Yaw offset", autodirection())
    }
    if(!UI.GetValue.apply(null, override))
    {
        AntiAim.SetOverride(0)
        return
    }
    AntiAim.SetOverride(1)
    var real_type = UI.GetValue.apply(null, ui.real_type)
    var lby_type = UI.GetValue.apply(null, ui.lby_type)
    var real_additional_type = UI.GetValue.apply(null, ui.real_additional_type)
    var moving_real_type = UI.GetValue.apply(null,ui.moving_real_type)
    var inverter = UI.IsHotkeyActive("Anti-Aim", "Fake angles", "Inverter")
    var antibrute = UI.GetValue.apply(null,brutee)
    if(antibrute)
    {
        smart_lby(inverter, false)
        process_shot()
        var enemies = Entity.GetEnemies()
        var enemy_shooting = -1
        for(i in enemies)
        {
            if(!Entity.IsAlive(enemies[i]) || Entity.IsDormant(enemies[i]))
                continue
            var time = Entity.GetProp(enemies[i], "CCSPlayer", "m_nTickBase") * Globals.TickInterval()
            var next_primary_attack = Entity.GetProp(Entity.GetWeapon(enemies[i]), "CBaseCombatWeapon", "m_flNextPrimaryAttack")
            var ammo = Entity.GetProp(Entity.GetWeapon(enemies[i]), "CBaseCombatWeapon", "m_iClip1")
            var canshoot = (next_primary_attack <= time && ammo > 0)
            if(canshoot)
            {
                enemy_shooting = enemies[i]
                break
            }
        }
 
        if(enemy_shooting == -1)
            return
        if(!enemy_brute_stage[enemy_shooting])
            enemy_brute_stage[enemy_shooting] = 0
        switch(enemy_brute_stage[enemy_shooting])
        {
            case 0: AntiAim.SetRealOffset(0); break
            case 1: AntiAim.SetRealOffset(58); break
            case 2: AntiAim.SetRealOffset(-58); break
        }
        return
    }
    var real_yaw = 0

    switch(real_type)
    {
        case 0: AntiAim.SetRealOffset(inverter ? 58 : -58); real_yaw = inverter ? 58 : -58; break
        case 1: AntiAim.SetRealOffset(inverter ? -58 : 58); real_yaw = inverter ? -58 : 58; break
        case 2: AntiAim.SetRealOffset(0); break
        case 3: real_yaw = smart_middle(inverter); break
        case 4: real_yaw = follow_fake(inverter, false); break
        case 5: real_yaw = follow_fake(inverter, true); break
        case 6: AntiAim.SetRealOffset(smart_yaw(inverter) ? 58 : -58); break
        case 7: AntiAim.SetRealOffset(smart_yaw(inverter) ? -58 : 58); break
    }
    switch(lby_type)
    {
        case 0: LBY_opposite(inverter); break
        case 1: AntiAim.SetLBYOffset(0); break
        case 2: switch_opposite(inverter); break
        case 3: smart_lby(inverter, false); break
        case 4: smart_lby(inverter, true); break
    }
    switch(real_additional_type)
    {
        case 1: AntiAim.SetRealOffset(Math.sin(Globals.Curtime() * 5) * 58); break
        case 2: AntiAim.SetRealOffset(Math.random() * 58 * 2 - 58); break
        case 3: half_sine(inverter, real_yaw); break
        case 4: half_jitter(inverter, real_yaw); break
    }
    switch(moving_real_type)
    {
        case 1: switch_real_moving(inverter); break
        case 2: jitter_real_moving(inverter); break
        case 3: sine_real_moving(inverter); break
    }
}
Cheat.RegisterCallback("round_start", "reset")
Cheat.RegisterCallback("weapon_fire", "weapon_fire")
Cheat.RegisterCallback("bullet_impact", "bullet_impact")
Cheat.RegisterCallback("player_hurt", "player_hurt")
Cheat.RegisterCallback("CreateMove", "onCreateMove")